# 구현, 시간복잡도, 누적합

## 백준_1620

이 문제의 핵심은 다음과 같다. 

1. atoi()함수의 사용
- 문자열과 int의 자료형이 섞여 있을 때 타입의 판단을 atoi()함수를 통해 할 수 있다. 
- atoi()는 만약 인자가 문자열이라면 0을 문자열로 표시된 숫자라면 그 숫자를 반환한다.
- atoi()함수의 사용은 다음과 같다. 
```
string s = "심정호";
atoi(s.c_str()); // 0
```
```
string s = "5";
atoi(s.c_str()); //5
```

2. 자료구조 map의 사용
- map은 구현 문제에서 특히 많이 나오는 자료구조이다. 
- map은 key, value의 쌍을 가지고 key의 값은 유일하다. 
- 따라서 종류를 판단하여 개수를 세는 등의 문제에 적합하다.
- map은 따로 순서를 정해줄 필요없이 같은 key에 해당하는 값을 처리해준다.
- key는 first value는 .second로 접근 가능하다.

## 백준_2559

이 문제의 핵심은 다음과 같다. 

1. 누적합
누적합은 값을 입력받음에 동시에 이전 값과 입력 받은 값을 더한 값을 현재 배열의 인덱스에 저장하는 방식이다. 

따라서 이 문제에서는 입력 받음과 동시에 누적합 배열을 구축하여 인덱스 간 차이를 O(N) 시간 복잡도로 구할 수 있다. 

```
cin >> temp; date[i] = date[i - 1] + temp;

for (int i = K; i <= N; i++) {
		res = max(res, date[i] - date[i - K]);
	}
```

## 백준_9375

이 문제의 핵심은 다음과 같다. 

1. map의 사용
- 이 문제는 각 테스트 케이스별로 지역변수 map을 만들어주어야한다. 
- 종류가 입력으로 들어오면 그 키에 해당하는 map의 value가 자동으로 ++된다. 
```
    map<string, int> _map;
		for (int i = 1; i <= N; i++) {
			cin >> name >> kind;
			_map[kind]++;
		}
```

2. map의 iterator
- map에서 key를 통한 순회 탐색이 가능하다. 
```
        for (auto c : _map) {
			ret *= ((long long)c.second + 1);
		}
```
